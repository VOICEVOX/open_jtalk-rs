/* automatically generated by rust-bindgen 0.70.1 */

pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
/// DictionaryInfo structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_dictionary_info_t {
    /** filename of dictionary
 On Windows, filename is stored in UTF-8 encoding*/
    pub filename: *const ::std::os::raw::c_char,
    /// character set of the dictionary. e.g., "SHIFT-JIS", "UTF-8"
    pub charset: *const ::std::os::raw::c_char,
    /// How many words are registered in this dictionary.
    pub size: ::std::os::raw::c_uint,
    /** dictionary type
 this value should be MECAB_USR_DIC, MECAB_SYS_DIC, or MECAB_UNK_DIC.*/
    pub type_: ::std::os::raw::c_int,
    /// left attributes size
    pub lsize: ::std::os::raw::c_uint,
    /// right attributes size
    pub rsize: ::std::os::raw::c_uint,
    /// version of this dictionary
    pub version: ::std::os::raw::c_ushort,
    /// pointer to the next dictionary info.
    pub next: *mut mecab_dictionary_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of mecab_dictionary_info_t",
    ][::std::mem::size_of::<mecab_dictionary_info_t>() - 48usize];
    [
        "Alignment of mecab_dictionary_info_t",
    ][::std::mem::align_of::<mecab_dictionary_info_t>() - 8usize];
    [
        "Offset of field: mecab_dictionary_info_t::filename",
    ][::std::mem::offset_of!(mecab_dictionary_info_t, filename) - 0usize];
    [
        "Offset of field: mecab_dictionary_info_t::charset",
    ][::std::mem::offset_of!(mecab_dictionary_info_t, charset) - 8usize];
    [
        "Offset of field: mecab_dictionary_info_t::size",
    ][::std::mem::offset_of!(mecab_dictionary_info_t, size) - 16usize];
    [
        "Offset of field: mecab_dictionary_info_t::type_",
    ][::std::mem::offset_of!(mecab_dictionary_info_t, type_) - 20usize];
    [
        "Offset of field: mecab_dictionary_info_t::lsize",
    ][::std::mem::offset_of!(mecab_dictionary_info_t, lsize) - 24usize];
    [
        "Offset of field: mecab_dictionary_info_t::rsize",
    ][::std::mem::offset_of!(mecab_dictionary_info_t, rsize) - 28usize];
    [
        "Offset of field: mecab_dictionary_info_t::version",
    ][::std::mem::offset_of!(mecab_dictionary_info_t, version) - 32usize];
    [
        "Offset of field: mecab_dictionary_info_t::next",
    ][::std::mem::offset_of!(mecab_dictionary_info_t, next) - 40usize];
};
/// Path structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_path_t {
    /// pointer to the right node
    pub rnode: *mut mecab_node_t,
    /// pointer to the next right path
    pub rnext: *mut mecab_path_t,
    /// pointer to the left node
    pub lnode: *mut mecab_node_t,
    /// pointer to the next left path
    pub lnext: *mut mecab_path_t,
    /// local cost
    pub cost: ::std::os::raw::c_int,
    /// marginal probability
    pub prob: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mecab_path_t"][::std::mem::size_of::<mecab_path_t>() - 40usize];
    ["Alignment of mecab_path_t"][::std::mem::align_of::<mecab_path_t>() - 8usize];
    [
        "Offset of field: mecab_path_t::rnode",
    ][::std::mem::offset_of!(mecab_path_t, rnode) - 0usize];
    [
        "Offset of field: mecab_path_t::rnext",
    ][::std::mem::offset_of!(mecab_path_t, rnext) - 8usize];
    [
        "Offset of field: mecab_path_t::lnode",
    ][::std::mem::offset_of!(mecab_path_t, lnode) - 16usize];
    [
        "Offset of field: mecab_path_t::lnext",
    ][::std::mem::offset_of!(mecab_path_t, lnext) - 24usize];
    [
        "Offset of field: mecab_path_t::cost",
    ][::std::mem::offset_of!(mecab_path_t, cost) - 32usize];
    [
        "Offset of field: mecab_path_t::prob",
    ][::std::mem::offset_of!(mecab_path_t, prob) - 36usize];
};
/// Node structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_node_t {
    /// pointer to the previous node.
    pub prev: *mut mecab_node_t,
    /// pointer to the next node.
    pub next: *mut mecab_node_t,
    /// pointer to the node which ends at the same position.
    pub enext: *mut mecab_node_t,
    /// pointer to the node which starts at the same position.
    pub bnext: *mut mecab_node_t,
    /** pointer to the right path.
 this value is NULL if MECAB_ONE_BEST mode.*/
    pub rpath: *mut mecab_path_t,
    /** pointer to the right path.
 this value is NULL if MECAB_ONE_BEST mode.*/
    pub lpath: *mut mecab_path_t,
    /** surface string.
 this value is not 0 terminated.
 You can get the length with length/rlength members.*/
    pub surface: *const ::std::os::raw::c_char,
    /// feature string
    pub feature: *const ::std::os::raw::c_char,
    /// unique node id
    pub id: ::std::os::raw::c_uint,
    /// length of the surface form.
    pub length: ::std::os::raw::c_ushort,
    /// length of the surface form including white space before the morph.
    pub rlength: ::std::os::raw::c_ushort,
    /// right attribute id
    pub rcAttr: ::std::os::raw::c_ushort,
    /// left attribute id
    pub lcAttr: ::std::os::raw::c_ushort,
    /// unique part of speech id. This value is defined in "pos.def" file.
    pub posid: ::std::os::raw::c_ushort,
    /// character type
    pub char_type: ::std::os::raw::c_uchar,
    /** status of this model.
 This value is MECAB_NOR_NODE, MECAB_UNK_NODE, MECAB_BOS_NODE, MECAB_EOS_NODE, or MECAB_EON_NODE.*/
    pub stat: ::std::os::raw::c_uchar,
    /// set 1 if this node is best node.
    pub isbest: ::std::os::raw::c_uchar,
    /** forward accumulative log summation.
 This value is only available when MECAB_MARGINAL_PROB is passed.*/
    pub alpha: f32,
    /** backward accumulative log summation.
 This value is only available when MECAB_MARGINAL_PROB is passed.*/
    pub beta: f32,
    /** marginal probability.
 This value is only available when MECAB_MARGINAL_PROB is passed.*/
    pub prob: f32,
    /// word cost.
    pub wcost: ::std::os::raw::c_short,
    /// best accumulative cost from bos node to this node.
    pub cost: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mecab_node_t"][::std::mem::size_of::<mecab_node_t>() - 112usize];
    ["Alignment of mecab_node_t"][::std::mem::align_of::<mecab_node_t>() - 8usize];
    [
        "Offset of field: mecab_node_t::prev",
    ][::std::mem::offset_of!(mecab_node_t, prev) - 0usize];
    [
        "Offset of field: mecab_node_t::next",
    ][::std::mem::offset_of!(mecab_node_t, next) - 8usize];
    [
        "Offset of field: mecab_node_t::enext",
    ][::std::mem::offset_of!(mecab_node_t, enext) - 16usize];
    [
        "Offset of field: mecab_node_t::bnext",
    ][::std::mem::offset_of!(mecab_node_t, bnext) - 24usize];
    [
        "Offset of field: mecab_node_t::rpath",
    ][::std::mem::offset_of!(mecab_node_t, rpath) - 32usize];
    [
        "Offset of field: mecab_node_t::lpath",
    ][::std::mem::offset_of!(mecab_node_t, lpath) - 40usize];
    [
        "Offset of field: mecab_node_t::surface",
    ][::std::mem::offset_of!(mecab_node_t, surface) - 48usize];
    [
        "Offset of field: mecab_node_t::feature",
    ][::std::mem::offset_of!(mecab_node_t, feature) - 56usize];
    [
        "Offset of field: mecab_node_t::id",
    ][::std::mem::offset_of!(mecab_node_t, id) - 64usize];
    [
        "Offset of field: mecab_node_t::length",
    ][::std::mem::offset_of!(mecab_node_t, length) - 68usize];
    [
        "Offset of field: mecab_node_t::rlength",
    ][::std::mem::offset_of!(mecab_node_t, rlength) - 70usize];
    [
        "Offset of field: mecab_node_t::rcAttr",
    ][::std::mem::offset_of!(mecab_node_t, rcAttr) - 72usize];
    [
        "Offset of field: mecab_node_t::lcAttr",
    ][::std::mem::offset_of!(mecab_node_t, lcAttr) - 74usize];
    [
        "Offset of field: mecab_node_t::posid",
    ][::std::mem::offset_of!(mecab_node_t, posid) - 76usize];
    [
        "Offset of field: mecab_node_t::char_type",
    ][::std::mem::offset_of!(mecab_node_t, char_type) - 78usize];
    [
        "Offset of field: mecab_node_t::stat",
    ][::std::mem::offset_of!(mecab_node_t, stat) - 79usize];
    [
        "Offset of field: mecab_node_t::isbest",
    ][::std::mem::offset_of!(mecab_node_t, isbest) - 80usize];
    [
        "Offset of field: mecab_node_t::alpha",
    ][::std::mem::offset_of!(mecab_node_t, alpha) - 84usize];
    [
        "Offset of field: mecab_node_t::beta",
    ][::std::mem::offset_of!(mecab_node_t, beta) - 88usize];
    [
        "Offset of field: mecab_node_t::prob",
    ][::std::mem::offset_of!(mecab_node_t, prob) - 92usize];
    [
        "Offset of field: mecab_node_t::wcost",
    ][::std::mem::offset_of!(mecab_node_t, wcost) - 96usize];
    [
        "Offset of field: mecab_node_t::cost",
    ][::std::mem::offset_of!(mecab_node_t, cost) - 104usize];
};
pub const MECAB_NOR_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_NOR_NODE;
pub const MECAB_UNK_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_UNK_NODE;
pub const MECAB_BOS_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_BOS_NODE;
pub const MECAB_EOS_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_EOS_NODE;
pub const MECAB_EON_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_EON_NODE;
#[repr(u32)]
/// Parameters for MeCab::Node::stat
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    /// Normal node defined in the dictionary.
    MECAB_NOR_NODE = 0,
    /// Unknown node not defined in the dictionary.
    MECAB_UNK_NODE = 1,
    /// Virtual node representing a beginning of the sentence.
    MECAB_BOS_NODE = 2,
    /// Virtual node representing a end of the sentence.
    MECAB_EOS_NODE = 3,
    /// Virtual node representing a end of the N-best enumeration.
    MECAB_EON_NODE = 4,
}
pub const MECAB_SYS_DIC: _bindgen_ty_2 = _bindgen_ty_2::MECAB_SYS_DIC;
pub const MECAB_USR_DIC: _bindgen_ty_2 = _bindgen_ty_2::MECAB_USR_DIC;
pub const MECAB_UNK_DIC: _bindgen_ty_2 = _bindgen_ty_2::MECAB_UNK_DIC;
#[repr(u32)]
/// Parameters for MeCab::DictionaryInfo::type
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    /// This is a system dictionary.
    MECAB_SYS_DIC = 0,
    /// This is a user dictionary.
    MECAB_USR_DIC = 1,
    /// This is a unknown word dictionary.
    MECAB_UNK_DIC = 2,
}
pub const MECAB_ONE_BEST: _bindgen_ty_3 = _bindgen_ty_3::MECAB_ONE_BEST;
pub const MECAB_NBEST: _bindgen_ty_3 = _bindgen_ty_3::MECAB_NBEST;
pub const MECAB_PARTIAL: _bindgen_ty_3 = _bindgen_ty_3::MECAB_PARTIAL;
pub const MECAB_MARGINAL_PROB: _bindgen_ty_3 = _bindgen_ty_3::MECAB_MARGINAL_PROB;
pub const MECAB_ALTERNATIVE: _bindgen_ty_3 = _bindgen_ty_3::MECAB_ALTERNATIVE;
pub const MECAB_ALL_MORPHS: _bindgen_ty_3 = _bindgen_ty_3::MECAB_ALL_MORPHS;
pub const MECAB_ALLOCATE_SENTENCE: _bindgen_ty_3 = _bindgen_ty_3::MECAB_ALLOCATE_SENTENCE;
#[repr(u32)]
/// Parameters for MeCab::Lattice::request_type
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    /// One best result is obtained (default mode)
    MECAB_ONE_BEST = 1,
    /// Set this flag if you want to obtain N best results.
    MECAB_NBEST = 2,
    /** Set this flag if you want to enable a partial parsing mode.
 When this flag is set, the input |sentence| needs to be written
 in partial parsing format.*/
    MECAB_PARTIAL = 4,
    /** Set this flag if you want to obtain marginal probabilities.
 Marginal probability is set in MeCab::Node::prob.
 The parsing speed will get 3-5 times slower than the default mode.*/
    MECAB_MARGINAL_PROB = 8,
    /** Set this flag if you want to obtain alternative results.
 Not implemented.*/
    MECAB_ALTERNATIVE = 16,
    /** When this flag is set, the result linked-list (Node::next/prev)
 traverses all nodes in the lattice.*/
    MECAB_ALL_MORPHS = 32,
    /** When this flag is set, tagger internally copies the body of passed
 sentence into internal buffer.*/
    MECAB_ALLOCATE_SENTENCE = 64,
}
pub const MECAB_ANY_BOUNDARY: _bindgen_ty_4 = _bindgen_ty_4::MECAB_ANY_BOUNDARY;
pub const MECAB_TOKEN_BOUNDARY: _bindgen_ty_4 = _bindgen_ty_4::MECAB_TOKEN_BOUNDARY;
pub const MECAB_INSIDE_TOKEN: _bindgen_ty_4 = _bindgen_ty_4::MECAB_INSIDE_TOKEN;
#[repr(u32)]
/// Parameters for MeCab::Lattice::boundary_constraint_type
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    /// The token boundary is not specified.
    MECAB_ANY_BOUNDARY = 0,
    /// The position is a strong token boundary.
    MECAB_TOKEN_BOUNDARY = 1,
    /// The position is not a token boundary.
    MECAB_INSIDE_TOKEN = 2,
}
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    [
        "Offset of field: _IO_FILE::_flags",
    ][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    [
        "Offset of field: _IO_FILE::_IO_read_ptr",
    ][::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    [
        "Offset of field: _IO_FILE::_IO_read_end",
    ][::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    [
        "Offset of field: _IO_FILE::_IO_read_base",
    ][::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    [
        "Offset of field: _IO_FILE::_IO_write_base",
    ][::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    [
        "Offset of field: _IO_FILE::_IO_write_ptr",
    ][::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    [
        "Offset of field: _IO_FILE::_IO_write_end",
    ][::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    [
        "Offset of field: _IO_FILE::_IO_buf_base",
    ][::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    [
        "Offset of field: _IO_FILE::_IO_buf_end",
    ][::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    [
        "Offset of field: _IO_FILE::_IO_save_base",
    ][::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    [
        "Offset of field: _IO_FILE::_IO_backup_base",
    ][::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    [
        "Offset of field: _IO_FILE::_IO_save_end",
    ][::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    [
        "Offset of field: _IO_FILE::_markers",
    ][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    [
        "Offset of field: _IO_FILE::_chain",
    ][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    [
        "Offset of field: _IO_FILE::_fileno",
    ][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    [
        "Offset of field: _IO_FILE::_flags2",
    ][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    [
        "Offset of field: _IO_FILE::_old_offset",
    ][::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    [
        "Offset of field: _IO_FILE::_cur_column",
    ][::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    [
        "Offset of field: _IO_FILE::_vtable_offset",
    ][::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    [
        "Offset of field: _IO_FILE::_shortbuf",
    ][::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    [
        "Offset of field: _IO_FILE::_lock",
    ][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    [
        "Offset of field: _IO_FILE::_offset",
    ][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    [
        "Offset of field: _IO_FILE::_codecvt",
    ][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    [
        "Offset of field: _IO_FILE::_wide_data",
    ][::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    [
        "Offset of field: _IO_FILE::_freeres_list",
    ][::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    [
        "Offset of field: _IO_FILE::_freeres_buf",
    ][::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    [
        "Offset of field: _IO_FILE::__pad5",
    ][::std::mem::offset_of!(_IO_FILE, __pad5) - 184usize];
    [
        "Offset of field: _IO_FILE::_mode",
    ][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    [
        "Offset of field: _IO_FILE::_unused2",
    ][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_model_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_lattice_t {
    _unused: [u8; 0],
}
extern "C" {
    /// C wrapper of MeCab::Tagger::create(argc, argv)
    pub fn mecab_new(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut mecab_t;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::create(arg)
    pub fn mecab_new2(arg: *const ::std::os::raw::c_char) -> *mut mecab_t;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::version()
    pub fn mecab_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::getLastError()
    pub fn mecab_strerror(mecab: *mut mecab_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::deleteTagger(tagger)
    pub fn mecab_destroy(mecab: *mut mecab_t);
}
extern "C" {
    /// C wrapper of MeCab::Tagger:set_partial()
    pub fn mecab_get_partial(mecab: *mut mecab_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::partial()
    pub fn mecab_set_partial(mecab: *mut mecab_t, partial: ::std::os::raw::c_int);
}
extern "C" {
    /// C wrapper of MeCab::Tagger::theta()
    pub fn mecab_get_theta(mecab: *mut mecab_t) -> f32;
}
extern "C" {
    /// C wrapper of  MeCab::Tagger::set_theta()
    pub fn mecab_set_theta(mecab: *mut mecab_t, theta: f32);
}
extern "C" {
    /// C wrapper of MeCab::Tagger::lattice_level()
    pub fn mecab_get_lattice_level(mecab: *mut mecab_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::set_lattice_level()
    pub fn mecab_set_lattice_level(mecab: *mut mecab_t, level: ::std::os::raw::c_int);
}
extern "C" {
    /// C wrapper of MeCab::Tagger::all_morphs()
    pub fn mecab_get_all_morphs(mecab: *mut mecab_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::set_all_moprhs()
    pub fn mecab_set_all_morphs(mecab: *mut mecab_t, all_morphs: ::std::os::raw::c_int);
}
extern "C" {
    /// C wrapper of MeCab::Tagger::parse(MeCab::Lattice *lattice)
    pub fn mecab_parse_lattice(
        mecab: *mut mecab_t,
        lattice: *mut mecab_lattice_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::parse(const char *str)
    pub fn mecab_sparse_tostr(
        mecab: *mut mecab_t,
        str_: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::parse(const char *str, size_t len)
    pub fn mecab_sparse_tostr2(
        mecab: *mut mecab_t,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::parse(const char *str, char *ostr, size_t olen)
    pub fn mecab_sparse_tostr3(
        mecab: *mut mecab_t,
        str_: *const ::std::os::raw::c_char,
        len: usize,
        ostr: *mut ::std::os::raw::c_char,
        olen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::parseToNode(const char *str)
    pub fn mecab_sparse_tonode(
        mecab: *mut mecab_t,
        arg1: *const ::std::os::raw::c_char,
    ) -> *const mecab_node_t;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::parseToNode(const char *str, size_t len)
    pub fn mecab_sparse_tonode2(
        mecab: *mut mecab_t,
        arg1: *const ::std::os::raw::c_char,
        arg2: usize,
    ) -> *const mecab_node_t;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::parseNBest(size_t N, const char *str)
    pub fn mecab_nbest_sparse_tostr(
        mecab: *mut mecab_t,
        N: usize,
        str_: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::parseNBest(size_t N, const char *str, size_t len)
    pub fn mecab_nbest_sparse_tostr2(
        mecab: *mut mecab_t,
        N: usize,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::parseNBest(size_t N, const char *str, char *ostr, size_t olen)
    pub fn mecab_nbest_sparse_tostr3(
        mecab: *mut mecab_t,
        N: usize,
        str_: *const ::std::os::raw::c_char,
        len: usize,
        ostr: *mut ::std::os::raw::c_char,
        olen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::parseNBestInit(const char *str)
    pub fn mecab_nbest_init(
        mecab: *mut mecab_t,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::parseNBestInit(const char *str, size_t len)
    pub fn mecab_nbest_init2(
        mecab: *mut mecab_t,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::next()
    pub fn mecab_nbest_next_tostr(mecab: *mut mecab_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::next(char *ostr, size_t olen)
    pub fn mecab_nbest_next_tostr2(
        mecab: *mut mecab_t,
        ostr: *mut ::std::os::raw::c_char,
        olen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::nextNode()
    pub fn mecab_nbest_next_tonode(mecab: *mut mecab_t) -> *const mecab_node_t;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::formatNode(const Node *node)
    pub fn mecab_format_node(
        mecab: *mut mecab_t,
        node: *const mecab_node_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Tagger::dictionary_info()
    pub fn mecab_dictionary_info(mecab: *mut mecab_t) -> *const mecab_dictionary_info_t;
}
extern "C" {
    /// C wrapper of MeCab::createLattice()
    pub fn mecab_lattice_new() -> *mut mecab_lattice_t;
}
extern "C" {
    /// C wrapper of MeCab::deleteLattice(lattice)
    pub fn mecab_lattice_destroy(lattice: *mut mecab_lattice_t);
}
extern "C" {
    /// C wrapper of MeCab::Lattice::clear()
    pub fn mecab_lattice_clear(lattice: *mut mecab_lattice_t);
}
extern "C" {
    /// C wrapper of MeCab::Lattice::is_available()
    pub fn mecab_lattice_is_available(
        lattice: *mut mecab_lattice_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::bos_node()
    pub fn mecab_lattice_get_bos_node(
        lattice: *mut mecab_lattice_t,
    ) -> *mut mecab_node_t;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::eos_node()
    pub fn mecab_lattice_get_eos_node(
        lattice: *mut mecab_lattice_t,
    ) -> *mut mecab_node_t;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::begin_nodes()
    pub fn mecab_lattice_get_all_begin_nodes(
        lattice: *mut mecab_lattice_t,
    ) -> *mut *mut mecab_node_t;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::end_nodes()
    pub fn mecab_lattice_get_all_end_nodes(
        lattice: *mut mecab_lattice_t,
    ) -> *mut *mut mecab_node_t;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::begin_nodes(pos)
    pub fn mecab_lattice_get_begin_nodes(
        lattice: *mut mecab_lattice_t,
        pos: usize,
    ) -> *mut mecab_node_t;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::end_nodes(pos)
    pub fn mecab_lattice_get_end_nodes(
        lattice: *mut mecab_lattice_t,
        pos: usize,
    ) -> *mut mecab_node_t;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::sentence()
    pub fn mecab_lattice_get_sentence(
        lattice: *mut mecab_lattice_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::set_sentence(sentence)
    pub fn mecab_lattice_set_sentence(
        lattice: *mut mecab_lattice_t,
        sentence: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    /// C wrapper of MeCab::Lattice::set_sentence(sentence, len)
    pub fn mecab_lattice_set_sentence2(
        lattice: *mut mecab_lattice_t,
        sentence: *const ::std::os::raw::c_char,
        len: usize,
    );
}
extern "C" {
    /// C wrapper of MeCab::Lattice::size()
    pub fn mecab_lattice_get_size(lattice: *mut mecab_lattice_t) -> usize;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::Z()
    pub fn mecab_lattice_get_z(lattice: *mut mecab_lattice_t) -> f64;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::set_Z()
    pub fn mecab_lattice_set_z(lattice: *mut mecab_lattice_t, Z: f64);
}
extern "C" {
    /// C wrapper of MeCab::Lattice::theta()
    pub fn mecab_lattice_get_theta(lattice: *mut mecab_lattice_t) -> f64;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::set_theta()
    pub fn mecab_lattice_set_theta(lattice: *mut mecab_lattice_t, theta: f64);
}
extern "C" {
    /// C wrapper of MeCab::Lattice::next()
    pub fn mecab_lattice_next(lattice: *mut mecab_lattice_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::request_type()
    pub fn mecab_lattice_get_request_type(
        lattice: *mut mecab_lattice_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::has_request_type()
    pub fn mecab_lattice_has_request_type(
        lattice: *mut mecab_lattice_t,
        request_type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::set_request_type()
    pub fn mecab_lattice_set_request_type(
        lattice: *mut mecab_lattice_t,
        request_type: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// C wrapper of MeCab::Lattice::add_request_type()
    pub fn mecab_lattice_add_request_type(
        lattice: *mut mecab_lattice_t,
        request_type: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// C wrapper of MeCab::Lattice::remove_request_type()
    pub fn mecab_lattice_remove_request_type(
        lattice: *mut mecab_lattice_t,
        request_type: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// C wrapper of MeCab::Lattice::newNode();
    pub fn mecab_lattice_new_node(lattice: *mut mecab_lattice_t) -> *mut mecab_node_t;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::toString()
    pub fn mecab_lattice_tostr(
        lattice: *mut mecab_lattice_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::toString(buf, size)
    pub fn mecab_lattice_tostr2(
        lattice: *mut mecab_lattice_t,
        buf: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::enumNBestAsString(N)
    pub fn mecab_lattice_nbest_tostr(
        lattice: *mut mecab_lattice_t,
        N: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::enumNBestAsString(N, buf, size)
    pub fn mecab_lattice_nbest_tostr2(
        lattice: *mut mecab_lattice_t,
        N: usize,
        buf: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::has_constraint()
    pub fn mecab_lattice_has_constraint(
        lattice: *mut mecab_lattice_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::boundary_constraint(pos)
    pub fn mecab_lattice_get_boundary_constraint(
        lattice: *mut mecab_lattice_t,
        pos: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::feature_constraint(pos)
    pub fn mecab_lattice_get_feature_constraint(
        lattice: *mut mecab_lattice_t,
        pos: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wrapper of MeCab::Lattice::boundary_constraint(pos, type)
    pub fn mecab_lattice_set_boundary_constraint(
        lattice: *mut mecab_lattice_t,
        pos: usize,
        boundary_type: ::std::os::raw::c_int,
    );
}
extern "C" {
    /// C wrapper of MeCab::Lattice::set_feature_constraint(begin_pos, end_pos, feature)
    pub fn mecab_lattice_set_feature_constraint(
        lattice: *mut mecab_lattice_t,
        begin_pos: usize,
        end_pos: usize,
        feature: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    /// C wrapper of MeCab::Lattice::set_result(result);
    pub fn mecab_lattice_set_result(
        lattice: *mut mecab_lattice_t,
        result: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    /// C wrapper of MeCab::Lattice::what()
    pub fn mecab_lattice_strerror(
        lattice: *mut mecab_lattice_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// C wapper of MeCab::Model::create(argc, argv)
    pub fn mecab_model_new(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut mecab_model_t;
}
extern "C" {
    /// C wapper of MeCab::Model::create(arg)
    pub fn mecab_model_new2(arg: *const ::std::os::raw::c_char) -> *mut mecab_model_t;
}
extern "C" {
    /// C wapper of MeCab::deleteModel(model)
    pub fn mecab_model_destroy(model: *mut mecab_model_t);
}
extern "C" {
    /// C wapper of MeCab::Model::createTagger()
    pub fn mecab_model_new_tagger(model: *mut mecab_model_t) -> *mut mecab_t;
}
extern "C" {
    /// C wapper of MeCab::Model::createLattice()
    pub fn mecab_model_new_lattice(model: *mut mecab_model_t) -> *mut mecab_lattice_t;
}
extern "C" {
    /// C wrapper of MeCab::Model::swap()
    pub fn mecab_model_swap(
        model: *mut mecab_model_t,
        new_model: *mut mecab_model_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wapper of MeCab::Model::dictionary_info()
    pub fn mecab_model_dictionary_info(
        model: *mut mecab_model_t,
    ) -> *const mecab_dictionary_info_t;
}
extern "C" {
    /// C wrapper of MeCab::Model::transition_cost()
    pub fn mecab_model_transition_cost(
        model: *mut mecab_model_t,
        rcAttr: ::std::os::raw::c_ushort,
        lcAttr: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// C wrapper of MeCab::Model::lookup()
    pub fn mecab_model_lookup(
        model: *mut mecab_model_t,
        begin: *const ::std::os::raw::c_char,
        end: *const ::std::os::raw::c_char,
        lattice: *mut mecab_lattice_t,
    ) -> *mut mecab_node_t;
}
extern "C" {
    pub fn mecab_do(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mecab_dict_index(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mecab_dict_gen(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mecab_cost_train(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mecab_system_eval(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mecab_test_gen(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
/// DictionaryInfo structure
pub type MeCab_DictionaryInfo = mecab_dictionary_info_t;
/// Path structure
pub type MeCab_Path = mecab_path_t;
/// Node structure
pub type MeCab_Node = mecab_node_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MeCab_Allocator {
    pub _address: u8,
}
#[repr(C)]
pub struct MeCab_Lattice__bindgen_vtable(::std::os::raw::c_void);
/// Lattice class
#[repr(C)]
#[derive(Debug)]
pub struct MeCab_Lattice {
    pub vtable_: *const MeCab_Lattice__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MeCab_Lattice"][::std::mem::size_of::<MeCab_Lattice>() - 8usize];
    ["Alignment of MeCab_Lattice"][::std::mem::align_of::<MeCab_Lattice>() - 8usize];
};
extern "C" {
    /** Create new Lattice object
 @return new Lattice object*/
    #[link_name = "\u{1}_ZN5MeCab7Lattice6createEv"]
    pub fn MeCab_Lattice_create() -> *mut MeCab_Lattice;
}
impl MeCab_Lattice {
    #[inline]
    pub unsafe fn create() -> *mut MeCab_Lattice {
        MeCab_Lattice_create()
    }
}
#[repr(C)]
pub struct MeCab_Model__bindgen_vtable(::std::os::raw::c_void);
/// Model class
#[repr(C)]
#[derive(Debug)]
pub struct MeCab_Model {
    pub vtable_: *const MeCab_Model__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MeCab_Model"][::std::mem::size_of::<MeCab_Model>() - 8usize];
    ["Alignment of MeCab_Model"][::std::mem::align_of::<MeCab_Model>() - 8usize];
};
extern "C" {
    /** Return a version string
 @return version string*/
    #[link_name = "\u{1}_ZN5MeCab5Model7versionEv"]
    pub fn MeCab_Model_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /** Factory method to create a new Model with a specified main's argc/argv-style parameters.
 Return NULL if new model cannot be initialized. Use MeCab::getLastError() to obtain the
 cause of the errors.
 @return new Model object
 @param argc number of parameters
 @param argv parameter list*/
    #[link_name = "\u{1}_ZN5MeCab5Model6createEiPPc"]
    pub fn MeCab_Model_create(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Model;
}
extern "C" {
    /** Factory method to create a new Model with a string parameter representation, i.e.,
 "-d /user/local/mecab/dic/ipadic -Ochasen".
 Return NULL if new model cannot be initialized. Use MeCab::getLastError() to obtain the
 cause of the errors.
 @return new Model object
 @param arg single string representation of the argment.*/
    #[link_name = "\u{1}_ZN5MeCab5Model6createEPKc"]
    pub fn MeCab_Model_create1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Model;
}
impl MeCab_Model {
    #[inline]
    pub unsafe fn version() -> *const ::std::os::raw::c_char {
        MeCab_Model_version()
    }
    #[inline]
    pub unsafe fn create(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Model {
        MeCab_Model_create(argc, argv)
    }
    #[inline]
    pub unsafe fn create1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Model {
        MeCab_Model_create1(arg)
    }
}
#[repr(C)]
pub struct MeCab_Tagger__bindgen_vtable(::std::os::raw::c_void);
/// Tagger class
#[repr(C)]
#[derive(Debug)]
pub struct MeCab_Tagger {
    pub vtable_: *const MeCab_Tagger__bindgen_vtable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MeCab_Tagger"][::std::mem::size_of::<MeCab_Tagger>() - 8usize];
    ["Alignment of MeCab_Tagger"][::std::mem::align_of::<MeCab_Tagger>() - 8usize];
};
extern "C" {
    /** Handy static method.
 Return true if lattice is parsed successfully.
 This function is equivalent to
 {
   Tagger *tagger = model.createModel();
   cosnt bool result = tagger->parse(lattice);
   delete tagger;
   return result;
 }
 @return boolean*/
    #[link_name = "\u{1}_ZN5MeCab6Tagger5parseERKNS_5ModelEPNS_7LatticeE"]
    pub fn MeCab_Tagger_parse(
        model: *const MeCab_Model,
        lattice: *mut MeCab_Lattice,
    ) -> bool;
}
extern "C" {
    /** Factory method to create a new Tagger with a specified main's argc/argv-style parameters.
 Return NULL if new model cannot be initialized. Use MeCab::getLastError() to obtain the
 cause of the errors.
 @return new Tagger object
 @param argc number of parameters
 @param argv parameter list*/
    #[link_name = "\u{1}_ZN5MeCab6Tagger6createEiPPc"]
    pub fn MeCab_Tagger_create(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Tagger;
}
extern "C" {
    /** Factory method to create a new Tagger with a string parameter representation, i.e.,
 "-d /user/local/mecab/dic/ipadic -Ochasen".
 Return NULL if new model cannot be initialized. Use MeCab::getLastError() to obtain the
 cause of the errors.
 @return new Model object
 @param arg single string representation of the argment.*/
    #[link_name = "\u{1}_ZN5MeCab6Tagger6createEPKc"]
    pub fn MeCab_Tagger_create1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Tagger;
}
extern "C" {
    /** Return a version string
 @return version string*/
    #[link_name = "\u{1}_ZN5MeCab6Tagger7versionEv"]
    pub fn MeCab_Tagger_version() -> *const ::std::os::raw::c_char;
}
impl MeCab_Tagger {
    #[inline]
    pub unsafe fn parse(model: *const MeCab_Model, lattice: *mut MeCab_Lattice) -> bool {
        MeCab_Tagger_parse(model, lattice)
    }
    #[inline]
    pub unsafe fn create(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Tagger {
        MeCab_Tagger_create(argc, argv)
    }
    #[inline]
    pub unsafe fn create1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Tagger {
        MeCab_Tagger_create1(arg)
    }
    #[inline]
    pub unsafe fn version() -> *const ::std::os::raw::c_char {
        MeCab_Tagger_version()
    }
}
extern "C" {
    /// Alias of Lattice::create()
    #[link_name = "\u{1}_ZN5MeCab13createLatticeEv"]
    pub fn MeCab_createLattice() -> *mut MeCab_Lattice;
}
extern "C" {
    /// Alias of Mode::create(argc, argv)
    #[link_name = "\u{1}_ZN5MeCab11createModelEiPPc"]
    pub fn MeCab_createModel(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Model;
}
extern "C" {
    /// Alias of Mode::create(arg)
    #[link_name = "\u{1}_ZN5MeCab11createModelEPKc"]
    pub fn MeCab_createModel1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Model;
}
extern "C" {
    /// Alias of Tagger::create(argc, argv)
    #[link_name = "\u{1}_ZN5MeCab12createTaggerEiPPc"]
    pub fn MeCab_createTagger(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Tagger;
}
extern "C" {
    /// Alias of Tagger::create(arg)
    #[link_name = "\u{1}_ZN5MeCab12createTaggerEPKc"]
    pub fn MeCab_createTagger1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Tagger;
}
extern "C" {
    /** delete Lattice object.
 This method calles "delete lattice".
 In some environment, e.g., MS-Windows, an object allocated inside a DLL must be deleted in the same DLL too.
 @param lattice lattice object*/
    #[link_name = "\u{1}_ZN5MeCab13deleteLatticeEPNS_7LatticeE"]
    pub fn MeCab_deleteLattice(lattice: *mut MeCab_Lattice);
}
extern "C" {
    /** delete Model object.
 This method calles "delete model".
 In some environment, e.g., MS-Windows, an object allocated inside a DLL must be deleted in the same DLL too.
 @param model model object*/
    #[link_name = "\u{1}_ZN5MeCab11deleteModelEPNS_5ModelE"]
    pub fn MeCab_deleteModel(model: *mut MeCab_Model);
}
extern "C" {
    /** delete Tagger object.
 This method calles "delete tagger".
 In some environment, e.g., MS-Windows, an object allocated inside a DLL must be deleted in the same DLL too.
 @param tagger tagger object*/
    #[link_name = "\u{1}_ZN5MeCab12deleteTaggerEPNS_6TaggerE"]
    pub fn MeCab_deleteTagger(tagger: *mut MeCab_Tagger);
}
extern "C" {
    /** Return last error string.
 @return error string*/
    #[link_name = "\u{1}_ZN5MeCab12getLastErrorEv"]
    pub fn MeCab_getLastError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /** An alias of getLastError.
 It is kept for backward compatibility.
 @return error string*/
    #[link_name = "\u{1}_ZN5MeCab14getTaggerErrorEv"]
    pub fn MeCab_getTaggerError() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mecab {
    pub feature: *mut *mut ::std::os::raw::c_char,
    pub size: ::std::os::raw::c_int,
    pub model: *mut ::std::os::raw::c_void,
    pub tagger: *mut ::std::os::raw::c_void,
    pub lattice: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Mecab"][::std::mem::size_of::<_Mecab>() - 40usize];
    ["Alignment of _Mecab"][::std::mem::align_of::<_Mecab>() - 8usize];
    [
        "Offset of field: _Mecab::feature",
    ][::std::mem::offset_of!(_Mecab, feature) - 0usize];
    ["Offset of field: _Mecab::size"][::std::mem::offset_of!(_Mecab, size) - 8usize];
    ["Offset of field: _Mecab::model"][::std::mem::offset_of!(_Mecab, model) - 16usize];
    [
        "Offset of field: _Mecab::tagger",
    ][::std::mem::offset_of!(_Mecab, tagger) - 24usize];
    [
        "Offset of field: _Mecab::lattice",
    ][::std::mem::offset_of!(_Mecab, lattice) - 32usize];
};
pub type Mecab = _Mecab;
extern "C" {
    pub fn Mecab_initialize(m: *mut Mecab) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_load(
        m: *mut Mecab,
        dicdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_load_with_userdic(
        m: *mut Mecab,
        dicdir: *const ::std::os::raw::c_char,
        userdic: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_analysis(
        m: *mut Mecab,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_print(m: *mut Mecab) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_get_size(m: *mut Mecab) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_get_feature(m: *mut Mecab) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Mecab_refresh(m: *mut Mecab) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_clear(m: *mut Mecab) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NJDNode {
    pub string: *mut ::std::os::raw::c_char,
    pub pos: *mut ::std::os::raw::c_char,
    pub pos_group1: *mut ::std::os::raw::c_char,
    pub pos_group2: *mut ::std::os::raw::c_char,
    pub pos_group3: *mut ::std::os::raw::c_char,
    pub ctype: *mut ::std::os::raw::c_char,
    pub cform: *mut ::std::os::raw::c_char,
    pub orig: *mut ::std::os::raw::c_char,
    pub read: *mut ::std::os::raw::c_char,
    pub pron: *mut ::std::os::raw::c_char,
    pub acc: ::std::os::raw::c_int,
    pub mora_size: ::std::os::raw::c_int,
    pub chain_rule: *mut ::std::os::raw::c_char,
    pub chain_flag: ::std::os::raw::c_int,
    pub prev: *mut _NJDNode,
    pub next: *mut _NJDNode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NJDNode"][::std::mem::size_of::<_NJDNode>() - 120usize];
    ["Alignment of _NJDNode"][::std::mem::align_of::<_NJDNode>() - 8usize];
    [
        "Offset of field: _NJDNode::string",
    ][::std::mem::offset_of!(_NJDNode, string) - 0usize];
    ["Offset of field: _NJDNode::pos"][::std::mem::offset_of!(_NJDNode, pos) - 8usize];
    [
        "Offset of field: _NJDNode::pos_group1",
    ][::std::mem::offset_of!(_NJDNode, pos_group1) - 16usize];
    [
        "Offset of field: _NJDNode::pos_group2",
    ][::std::mem::offset_of!(_NJDNode, pos_group2) - 24usize];
    [
        "Offset of field: _NJDNode::pos_group3",
    ][::std::mem::offset_of!(_NJDNode, pos_group3) - 32usize];
    [
        "Offset of field: _NJDNode::ctype",
    ][::std::mem::offset_of!(_NJDNode, ctype) - 40usize];
    [
        "Offset of field: _NJDNode::cform",
    ][::std::mem::offset_of!(_NJDNode, cform) - 48usize];
    [
        "Offset of field: _NJDNode::orig",
    ][::std::mem::offset_of!(_NJDNode, orig) - 56usize];
    [
        "Offset of field: _NJDNode::read",
    ][::std::mem::offset_of!(_NJDNode, read) - 64usize];
    [
        "Offset of field: _NJDNode::pron",
    ][::std::mem::offset_of!(_NJDNode, pron) - 72usize];
    ["Offset of field: _NJDNode::acc"][::std::mem::offset_of!(_NJDNode, acc) - 80usize];
    [
        "Offset of field: _NJDNode::mora_size",
    ][::std::mem::offset_of!(_NJDNode, mora_size) - 84usize];
    [
        "Offset of field: _NJDNode::chain_rule",
    ][::std::mem::offset_of!(_NJDNode, chain_rule) - 88usize];
    [
        "Offset of field: _NJDNode::chain_flag",
    ][::std::mem::offset_of!(_NJDNode, chain_flag) - 96usize];
    [
        "Offset of field: _NJDNode::prev",
    ][::std::mem::offset_of!(_NJDNode, prev) - 104usize];
    [
        "Offset of field: _NJDNode::next",
    ][::std::mem::offset_of!(_NJDNode, next) - 112usize];
};
pub type NJDNode = _NJDNode;
extern "C" {
    pub fn NJDNode_initialize(node: *mut NJDNode);
}
extern "C" {
    pub fn NJDNode_set_string(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_pos(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_pos_group1(
        node: *mut NJDNode,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn NJDNode_set_pos_group2(
        node: *mut NJDNode,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn NJDNode_set_pos_group3(
        node: *mut NJDNode,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn NJDNode_set_ctype(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_cform(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_orig(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_read(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_pron(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_acc(node: *mut NJDNode, acc: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NJDNode_set_mora_size(node: *mut NJDNode, size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NJDNode_set_chain_rule(
        node: *mut NJDNode,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn NJDNode_set_chain_flag(node: *mut NJDNode, flag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NJDNode_add_string(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_add_orig(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_add_read(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_add_pron(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_add_acc(node: *mut NJDNode, acc: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NJDNode_add_mora_size(node: *mut NJDNode, size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NJDNode_get_string(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_pos(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_pos_group1(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_pos_group2(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_pos_group3(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_ctype(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_cform(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_orig(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_read(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_pron(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_acc(node: *mut NJDNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NJDNode_get_mora_size(node: *mut NJDNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NJDNode_get_chain_rule(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_chain_flag(node: *mut NJDNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NJDNode_load(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_insert(
        prev: *mut NJDNode,
        next: *mut NJDNode,
        node: *mut NJDNode,
    ) -> *mut NJDNode;
}
extern "C" {
    pub fn NJDNode_copy(node1: *mut NJDNode, node2: *mut NJDNode);
}
extern "C" {
    pub fn NJDNode_print(node: *mut NJDNode);
}
extern "C" {
    pub fn NJDNode_fprint(node: *mut NJDNode, fp: *mut FILE);
}
extern "C" {
    pub fn NJDNode_sprint(
        node: *mut NJDNode,
        buff: *mut ::std::os::raw::c_char,
        split_code: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn NJDNode_clear(node: *mut NJDNode);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NJD {
    pub head: *mut NJDNode,
    pub tail: *mut NJDNode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _NJD"][::std::mem::size_of::<_NJD>() - 16usize];
    ["Alignment of _NJD"][::std::mem::align_of::<_NJD>() - 8usize];
    ["Offset of field: _NJD::head"][::std::mem::offset_of!(_NJD, head) - 0usize];
    ["Offset of field: _NJD::tail"][::std::mem::offset_of!(_NJD, tail) - 8usize];
};
pub type NJD = _NJD;
extern "C" {
    pub fn NJD_initialize(njd: *mut NJD);
}
extern "C" {
    pub fn NJD_load(njd: *mut NJD, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJD_load_from_fp(njd: *mut NJD, fp: *mut FILE);
}
extern "C" {
    pub fn NJD_get_size(njd: *mut NJD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NJD_push_node(njd: *mut NJD, node: *mut NJDNode);
}
extern "C" {
    pub fn NJD_remove_node(njd: *mut NJD, node: *mut NJDNode) -> *mut NJDNode;
}
extern "C" {
    pub fn NJD_remove_silent_node(njd: *mut NJD);
}
extern "C" {
    pub fn NJD_print(njd: *mut NJD);
}
extern "C" {
    pub fn NJD_fprint(njd: *mut NJD, fp: *mut FILE);
}
extern "C" {
    pub fn NJD_sprint(
        njd: *mut NJD,
        buff: *mut ::std::os::raw::c_char,
        split_code: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn NJD_refresh(njd: *mut NJD);
}
extern "C" {
    pub fn NJD_clear(wl: *mut NJD);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonLabelPhoneme {
    pub phoneme: *mut ::std::os::raw::c_char,
    pub prev: *mut _JPCommonLabelPhoneme,
    pub next: *mut _JPCommonLabelPhoneme,
    pub up: *mut _JPCommonLabelMora,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of _JPCommonLabelPhoneme",
    ][::std::mem::size_of::<_JPCommonLabelPhoneme>() - 32usize];
    [
        "Alignment of _JPCommonLabelPhoneme",
    ][::std::mem::align_of::<_JPCommonLabelPhoneme>() - 8usize];
    [
        "Offset of field: _JPCommonLabelPhoneme::phoneme",
    ][::std::mem::offset_of!(_JPCommonLabelPhoneme, phoneme) - 0usize];
    [
        "Offset of field: _JPCommonLabelPhoneme::prev",
    ][::std::mem::offset_of!(_JPCommonLabelPhoneme, prev) - 8usize];
    [
        "Offset of field: _JPCommonLabelPhoneme::next",
    ][::std::mem::offset_of!(_JPCommonLabelPhoneme, next) - 16usize];
    [
        "Offset of field: _JPCommonLabelPhoneme::up",
    ][::std::mem::offset_of!(_JPCommonLabelPhoneme, up) - 24usize];
};
pub type JPCommonLabelPhoneme = _JPCommonLabelPhoneme;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonLabelMora {
    pub mora: *mut ::std::os::raw::c_char,
    pub head: *mut _JPCommonLabelPhoneme,
    pub tail: *mut _JPCommonLabelPhoneme,
    pub prev: *mut _JPCommonLabelMora,
    pub next: *mut _JPCommonLabelMora,
    pub up: *mut _JPCommonLabelWord,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of _JPCommonLabelMora",
    ][::std::mem::size_of::<_JPCommonLabelMora>() - 48usize];
    [
        "Alignment of _JPCommonLabelMora",
    ][::std::mem::align_of::<_JPCommonLabelMora>() - 8usize];
    [
        "Offset of field: _JPCommonLabelMora::mora",
    ][::std::mem::offset_of!(_JPCommonLabelMora, mora) - 0usize];
    [
        "Offset of field: _JPCommonLabelMora::head",
    ][::std::mem::offset_of!(_JPCommonLabelMora, head) - 8usize];
    [
        "Offset of field: _JPCommonLabelMora::tail",
    ][::std::mem::offset_of!(_JPCommonLabelMora, tail) - 16usize];
    [
        "Offset of field: _JPCommonLabelMora::prev",
    ][::std::mem::offset_of!(_JPCommonLabelMora, prev) - 24usize];
    [
        "Offset of field: _JPCommonLabelMora::next",
    ][::std::mem::offset_of!(_JPCommonLabelMora, next) - 32usize];
    [
        "Offset of field: _JPCommonLabelMora::up",
    ][::std::mem::offset_of!(_JPCommonLabelMora, up) - 40usize];
};
pub type JPCommonLabelMora = _JPCommonLabelMora;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonLabelWord {
    pub pron: *mut ::std::os::raw::c_char,
    pub pos: *mut ::std::os::raw::c_char,
    pub ctype: *mut ::std::os::raw::c_char,
    pub cform: *mut ::std::os::raw::c_char,
    pub head: *mut _JPCommonLabelMora,
    pub tail: *mut _JPCommonLabelMora,
    pub prev: *mut _JPCommonLabelWord,
    pub next: *mut _JPCommonLabelWord,
    pub up: *mut _JPCommonLabelAccentPhrase,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of _JPCommonLabelWord",
    ][::std::mem::size_of::<_JPCommonLabelWord>() - 72usize];
    [
        "Alignment of _JPCommonLabelWord",
    ][::std::mem::align_of::<_JPCommonLabelWord>() - 8usize];
    [
        "Offset of field: _JPCommonLabelWord::pron",
    ][::std::mem::offset_of!(_JPCommonLabelWord, pron) - 0usize];
    [
        "Offset of field: _JPCommonLabelWord::pos",
    ][::std::mem::offset_of!(_JPCommonLabelWord, pos) - 8usize];
    [
        "Offset of field: _JPCommonLabelWord::ctype",
    ][::std::mem::offset_of!(_JPCommonLabelWord, ctype) - 16usize];
    [
        "Offset of field: _JPCommonLabelWord::cform",
    ][::std::mem::offset_of!(_JPCommonLabelWord, cform) - 24usize];
    [
        "Offset of field: _JPCommonLabelWord::head",
    ][::std::mem::offset_of!(_JPCommonLabelWord, head) - 32usize];
    [
        "Offset of field: _JPCommonLabelWord::tail",
    ][::std::mem::offset_of!(_JPCommonLabelWord, tail) - 40usize];
    [
        "Offset of field: _JPCommonLabelWord::prev",
    ][::std::mem::offset_of!(_JPCommonLabelWord, prev) - 48usize];
    [
        "Offset of field: _JPCommonLabelWord::next",
    ][::std::mem::offset_of!(_JPCommonLabelWord, next) - 56usize];
    [
        "Offset of field: _JPCommonLabelWord::up",
    ][::std::mem::offset_of!(_JPCommonLabelWord, up) - 64usize];
};
pub type JPCommonLabelWord = _JPCommonLabelWord;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonLabelAccentPhrase {
    pub accent: ::std::os::raw::c_int,
    pub emotion: *mut ::std::os::raw::c_char,
    pub head: *mut _JPCommonLabelWord,
    pub tail: *mut _JPCommonLabelWord,
    pub prev: *mut _JPCommonLabelAccentPhrase,
    pub next: *mut _JPCommonLabelAccentPhrase,
    pub up: *mut _JPCommonLabelBreathGroup,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of _JPCommonLabelAccentPhrase",
    ][::std::mem::size_of::<_JPCommonLabelAccentPhrase>() - 56usize];
    [
        "Alignment of _JPCommonLabelAccentPhrase",
    ][::std::mem::align_of::<_JPCommonLabelAccentPhrase>() - 8usize];
    [
        "Offset of field: _JPCommonLabelAccentPhrase::accent",
    ][::std::mem::offset_of!(_JPCommonLabelAccentPhrase, accent) - 0usize];
    [
        "Offset of field: _JPCommonLabelAccentPhrase::emotion",
    ][::std::mem::offset_of!(_JPCommonLabelAccentPhrase, emotion) - 8usize];
    [
        "Offset of field: _JPCommonLabelAccentPhrase::head",
    ][::std::mem::offset_of!(_JPCommonLabelAccentPhrase, head) - 16usize];
    [
        "Offset of field: _JPCommonLabelAccentPhrase::tail",
    ][::std::mem::offset_of!(_JPCommonLabelAccentPhrase, tail) - 24usize];
    [
        "Offset of field: _JPCommonLabelAccentPhrase::prev",
    ][::std::mem::offset_of!(_JPCommonLabelAccentPhrase, prev) - 32usize];
    [
        "Offset of field: _JPCommonLabelAccentPhrase::next",
    ][::std::mem::offset_of!(_JPCommonLabelAccentPhrase, next) - 40usize];
    [
        "Offset of field: _JPCommonLabelAccentPhrase::up",
    ][::std::mem::offset_of!(_JPCommonLabelAccentPhrase, up) - 48usize];
};
pub type JPCommonLabelAccentPhrase = _JPCommonLabelAccentPhrase;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonLabelBreathGroup {
    pub head: *mut _JPCommonLabelAccentPhrase,
    pub tail: *mut _JPCommonLabelAccentPhrase,
    pub prev: *mut _JPCommonLabelBreathGroup,
    pub next: *mut _JPCommonLabelBreathGroup,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of _JPCommonLabelBreathGroup",
    ][::std::mem::size_of::<_JPCommonLabelBreathGroup>() - 32usize];
    [
        "Alignment of _JPCommonLabelBreathGroup",
    ][::std::mem::align_of::<_JPCommonLabelBreathGroup>() - 8usize];
    [
        "Offset of field: _JPCommonLabelBreathGroup::head",
    ][::std::mem::offset_of!(_JPCommonLabelBreathGroup, head) - 0usize];
    [
        "Offset of field: _JPCommonLabelBreathGroup::tail",
    ][::std::mem::offset_of!(_JPCommonLabelBreathGroup, tail) - 8usize];
    [
        "Offset of field: _JPCommonLabelBreathGroup::prev",
    ][::std::mem::offset_of!(_JPCommonLabelBreathGroup, prev) - 16usize];
    [
        "Offset of field: _JPCommonLabelBreathGroup::next",
    ][::std::mem::offset_of!(_JPCommonLabelBreathGroup, next) - 24usize];
};
pub type JPCommonLabelBreathGroup = _JPCommonLabelBreathGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonLabel {
    pub size: ::std::os::raw::c_int,
    pub feature: *mut *mut ::std::os::raw::c_char,
    pub breath_head: *mut JPCommonLabelBreathGroup,
    pub breath_tail: *mut JPCommonLabelBreathGroup,
    pub accent_head: *mut JPCommonLabelAccentPhrase,
    pub accent_tail: *mut JPCommonLabelAccentPhrase,
    pub word_head: *mut JPCommonLabelWord,
    pub word_tail: *mut JPCommonLabelWord,
    pub mora_head: *mut JPCommonLabelMora,
    pub mora_tail: *mut JPCommonLabelMora,
    pub phoneme_head: *mut JPCommonLabelPhoneme,
    pub phoneme_tail: *mut JPCommonLabelPhoneme,
    pub short_pause_flag: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _JPCommonLabel"][::std::mem::size_of::<_JPCommonLabel>() - 104usize];
    ["Alignment of _JPCommonLabel"][::std::mem::align_of::<_JPCommonLabel>() - 8usize];
    [
        "Offset of field: _JPCommonLabel::size",
    ][::std::mem::offset_of!(_JPCommonLabel, size) - 0usize];
    [
        "Offset of field: _JPCommonLabel::feature",
    ][::std::mem::offset_of!(_JPCommonLabel, feature) - 8usize];
    [
        "Offset of field: _JPCommonLabel::breath_head",
    ][::std::mem::offset_of!(_JPCommonLabel, breath_head) - 16usize];
    [
        "Offset of field: _JPCommonLabel::breath_tail",
    ][::std::mem::offset_of!(_JPCommonLabel, breath_tail) - 24usize];
    [
        "Offset of field: _JPCommonLabel::accent_head",
    ][::std::mem::offset_of!(_JPCommonLabel, accent_head) - 32usize];
    [
        "Offset of field: _JPCommonLabel::accent_tail",
    ][::std::mem::offset_of!(_JPCommonLabel, accent_tail) - 40usize];
    [
        "Offset of field: _JPCommonLabel::word_head",
    ][::std::mem::offset_of!(_JPCommonLabel, word_head) - 48usize];
    [
        "Offset of field: _JPCommonLabel::word_tail",
    ][::std::mem::offset_of!(_JPCommonLabel, word_tail) - 56usize];
    [
        "Offset of field: _JPCommonLabel::mora_head",
    ][::std::mem::offset_of!(_JPCommonLabel, mora_head) - 64usize];
    [
        "Offset of field: _JPCommonLabel::mora_tail",
    ][::std::mem::offset_of!(_JPCommonLabel, mora_tail) - 72usize];
    [
        "Offset of field: _JPCommonLabel::phoneme_head",
    ][::std::mem::offset_of!(_JPCommonLabel, phoneme_head) - 80usize];
    [
        "Offset of field: _JPCommonLabel::phoneme_tail",
    ][::std::mem::offset_of!(_JPCommonLabel, phoneme_tail) - 88usize];
    [
        "Offset of field: _JPCommonLabel::short_pause_flag",
    ][::std::mem::offset_of!(_JPCommonLabel, short_pause_flag) - 96usize];
};
pub type JPCommonLabel = _JPCommonLabel;
extern "C" {
    pub fn JPCommonLabel_initialize(label: *mut JPCommonLabel);
}
extern "C" {
    pub fn JPCommonLabel_push_word(
        label: *mut JPCommonLabel,
        pron: *const ::std::os::raw::c_char,
        pos: *const ::std::os::raw::c_char,
        ctype: *const ::std::os::raw::c_char,
        cform: *const ::std::os::raw::c_char,
        acc: ::std::os::raw::c_int,
        chain_flag: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn JPCommonLabel_make(label: *mut JPCommonLabel);
}
extern "C" {
    pub fn JPCommonLabel_get_size(label: *mut JPCommonLabel) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn JPCommonLabel_get_feature(
        label: *mut JPCommonLabel,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn JPCommonLabel_print(label: *mut JPCommonLabel);
}
extern "C" {
    pub fn JPCommonLabel_fprint(label: *mut JPCommonLabel, fp: *mut FILE);
}
extern "C" {
    pub fn JPCommonLabel_clear(label: *mut JPCommonLabel);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonNode {
    pub pron: *mut ::std::os::raw::c_char,
    pub pos: *mut ::std::os::raw::c_char,
    pub ctype: *mut ::std::os::raw::c_char,
    pub cform: *mut ::std::os::raw::c_char,
    pub acc: ::std::os::raw::c_int,
    pub chain_flag: ::std::os::raw::c_int,
    pub prev: *mut _JPCommonNode,
    pub next: *mut _JPCommonNode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _JPCommonNode"][::std::mem::size_of::<_JPCommonNode>() - 56usize];
    ["Alignment of _JPCommonNode"][::std::mem::align_of::<_JPCommonNode>() - 8usize];
    [
        "Offset of field: _JPCommonNode::pron",
    ][::std::mem::offset_of!(_JPCommonNode, pron) - 0usize];
    [
        "Offset of field: _JPCommonNode::pos",
    ][::std::mem::offset_of!(_JPCommonNode, pos) - 8usize];
    [
        "Offset of field: _JPCommonNode::ctype",
    ][::std::mem::offset_of!(_JPCommonNode, ctype) - 16usize];
    [
        "Offset of field: _JPCommonNode::cform",
    ][::std::mem::offset_of!(_JPCommonNode, cform) - 24usize];
    [
        "Offset of field: _JPCommonNode::acc",
    ][::std::mem::offset_of!(_JPCommonNode, acc) - 32usize];
    [
        "Offset of field: _JPCommonNode::chain_flag",
    ][::std::mem::offset_of!(_JPCommonNode, chain_flag) - 36usize];
    [
        "Offset of field: _JPCommonNode::prev",
    ][::std::mem::offset_of!(_JPCommonNode, prev) - 40usize];
    [
        "Offset of field: _JPCommonNode::next",
    ][::std::mem::offset_of!(_JPCommonNode, next) - 48usize];
};
pub type JPCommonNode = _JPCommonNode;
extern "C" {
    pub fn JPCommonNode_initialize(node: *mut JPCommonNode);
}
extern "C" {
    pub fn JPCommonNode_set_pron(
        node: *mut JPCommonNode,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn JPCommonNode_set_pos(
        node: *mut JPCommonNode,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn JPCommonNode_set_ctype(
        node: *mut JPCommonNode,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn JPCommonNode_set_cform(
        node: *mut JPCommonNode,
        str_: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn JPCommonNode_set_acc(node: *mut JPCommonNode, acc: ::std::os::raw::c_int);
}
extern "C" {
    pub fn JPCommonNode_set_chain_flag(
        node: *mut JPCommonNode,
        flag: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn JPCommonNode_get_pron(
        node: *mut JPCommonNode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn JPCommonNode_get_pos(
        node: *mut JPCommonNode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn JPCommonNode_get_ctype(
        node: *mut JPCommonNode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn JPCommonNode_get_cform(
        node: *mut JPCommonNode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn JPCommonNode_get_acc(node: *mut JPCommonNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn JPCommonNode_get_chain_flag(node: *mut JPCommonNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn JPCommonNode_print(node: *mut JPCommonNode);
}
extern "C" {
    pub fn JPCommonNode_fprint(node: *mut JPCommonNode, fp: *mut FILE);
}
extern "C" {
    pub fn JPCommonNode_clear(node: *mut JPCommonNode);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommon {
    pub head: *mut JPCommonNode,
    pub tail: *mut JPCommonNode,
    pub label: *mut JPCommonLabel,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _JPCommon"][::std::mem::size_of::<_JPCommon>() - 24usize];
    ["Alignment of _JPCommon"][::std::mem::align_of::<_JPCommon>() - 8usize];
    [
        "Offset of field: _JPCommon::head",
    ][::std::mem::offset_of!(_JPCommon, head) - 0usize];
    [
        "Offset of field: _JPCommon::tail",
    ][::std::mem::offset_of!(_JPCommon, tail) - 8usize];
    [
        "Offset of field: _JPCommon::label",
    ][::std::mem::offset_of!(_JPCommon, label) - 16usize];
};
pub type JPCommon = _JPCommon;
extern "C" {
    pub fn JPCommon_initialize(jpcommon: *mut JPCommon);
}
extern "C" {
    pub fn JPCommon_push(jpcommon: *mut JPCommon, node: *mut JPCommonNode);
}
extern "C" {
    pub fn JPCommon_make_label(jpcommon: *mut JPCommon);
}
extern "C" {
    pub fn JPCommon_get_label_size(jpcommon: *mut JPCommon) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn JPCommon_get_label_feature(
        jpcommon: *mut JPCommon,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn JPCommon_print(jpcommon: *mut JPCommon);
}
extern "C" {
    pub fn JPCommon_fprint(jpcommon: *mut JPCommon, fp: *mut FILE);
}
extern "C" {
    pub fn JPCommon_refresh(jpcommon: *mut JPCommon);
}
extern "C" {
    pub fn JPCommon_clear(jpcommon: *mut JPCommon);
}
extern "C" {
    pub fn njd2jpcommon(jpcommon: *mut JPCommon, njd: *mut NJD);
}
extern "C" {
    pub fn njd_set_accent_phrase(njd: *mut NJD);
}
extern "C" {
    pub fn njd_set_accent_type(njd: *mut NJD);
}
extern "C" {
    pub fn njd_set_digit(njd: *mut NJD);
}
extern "C" {
    pub fn njd_set_long_vowel(njd: *mut NJD);
}
extern "C" {
    pub fn njd_set_pronunciation(njd: *mut NJD);
}
extern "C" {
    pub fn njd_set_unvoiced_vowel(njd: *mut NJD);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum text2mecab_result_t {
    TEXT2MECAB_RESULT_SUCCESS = 0,
    TEXT2MECAB_RESULT_INVALID_ARGUMENT = 1,
    TEXT2MECAB_RESULT_RANGE_ERROR = 2,
}
extern "C" {
    pub fn text2mecab(
        output: *mut ::std::os::raw::c_char,
        sizeOfOutput: usize,
        input: *const ::std::os::raw::c_char,
    ) -> text2mecab_result_t;
}
extern "C" {
    pub fn mecab2njd(
        njd: *mut NJD,
        feature: *mut *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    );
}
